import org.gradle.api.tasks.testing.logging.TestExceptionFormat.FULL
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.gradle.api.tasks.testing.logging.TestLogEvent.FAILED
import org.gradle.api.tasks.testing.logging.TestLogEvent.PASSED
import org.springframework.boot.gradle.plugin.SpringBootPlugin

/*
 * This file was generated by the Gradle 'init' task.
 */



group = "com.starlight.api.platform"
version = "1.0.0-SNAPSHOT"
description = "sms-satp"


plugins {
    val springVersion = "2.4.5"
    java
    checkstyle
    jacoco
    id("com.github.spotbugs") version "4.7.1"
    id("org.springframework.boot") version springVersion
    id("io.spring.dependency-management") version "1.0.11.RELEASE"

}

spotbugs {
    toolVersion.set("4.3.0")
    showProgress.set(true)
    effort.set(com.github.spotbugs.snom.Effort.MAX)
    reportLevel.set(com.github.spotbugs.snom.Confidence.LOW)
    omitVisitors.addAll(listOf("FindReturnRef", "RuntimeExceptionCapture"))
    sourceSets.add(sourceSets.main.get())

}

allprojects {
    java.sourceCompatibility = JavaVersion.VERSION_11
    java.targetCompatibility = JavaVersion.VERSION_11
}
checkstyle {
    group = "verification"
    toolVersion = "8.42"
    config = resources.text.fromFile("checkstyle.xml", "UTF-8")
    isShowViolations = true
    isIgnoreFailures = false
    maxWarnings = 0


}

jacoco {
    toolVersion = "0.8.6"


}

repositories {
//    mavenLocal()
    maven {
        url = uri("http://13.228.213.232:8081/repository/maven-public/")
        isAllowInsecureProtocol = true
    }
    mavenCentral()
}



dependencies {
    val versionLombok by extra("1.18.20")
    val versionMapstruct by extra("1.4.2.Final")
    val versionJjwt by extra("0.11.2")

    implementation(platform(SpringBootPlugin.BOM_COORDINATES))
    implementation("org.springframework.boot:spring-boot-starter-data-mongodb")
    implementation("org.springframework.boot:spring-boot-starter-web") {
        exclude(module = "spring-boot-starter-tomcat")
    }
    implementation("org.springframework.boot:spring-boot-starter-undertow")
    implementation("org.springframework.boot:spring-boot-starter-aop")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-websocket") {
        exclude(module = "spring-boot-starter-tomcat")
    }
    compileOnly("org.projectlombok:lombok:$versionLombok")
    annotationProcessor("org.mapstruct:mapstruct-processor:$versionMapstruct")
    annotationProcessor("org.projectlombok:lombok:$versionLombok")
    annotationProcessor("org.projectlombok:lombok-mapstruct-binding:0.2.0")
    compileOnly("org.mapstruct:mapstruct:$versionMapstruct")
    annotationProcessor("org.springframework.boot:spring-boot-configuration-processor")
    implementation("io.swagger.parser.v3:swagger-parser:2.0.27")
    implementation("org.springdoc:springdoc-openapi-ui:1.5.9")
    implementation("org.apache.commons:commons-lang3:3.12.0")
    implementation("commons-io:commons-io:2.8.0")
    implementation("org.apache.commons:commons-collections4:4.4")
    implementation("io.vavr:vavr:0.10.3")
    implementation("org.codehaus.groovy:groovy:3.0.8")
    compileOnly("com.github.spotbugs:spotbugs-annotations:${spotbugs.toolVersion.get()}")
    spotbugs("com.github.spotbugs:spotbugs:${spotbugs.toolVersion.get()}")
    implementation("io.jsonwebtoken:jjwt-api:$versionJjwt")
    implementation("io.jsonwebtoken:jjwt-impl:$versionJjwt")
    implementation("io.jsonwebtoken:jjwt-jackson:$versionJjwt")
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("de.flapdoodle.embed:de.flapdoodle.embed.mongo:2.2.0")
    testImplementation("org.springframework.security:spring-security-test")

}




tasks.checkstyleTest {
    group = "verification"
    enabled = false
}

tasks.checkstyleMain {
    group = "verification"

}

tasks.spotbugsTest {
    enabled = false
}

tasks.spotbugsMain {
    group = "verification"
}

tasks.jacocoTestReport {
    classDirectories.setFrom(sourceSets.main.get().output.asFileTree.matching {
        exclude("com/sms/satp/utils/**", "com/sms/satp/engine/**", "com/sms/satp/parser/converter/**.class", "com/sms/satp/common/**", "**/entity/**/**.class", "**/SatpApplication.class", "com/sms/satp/infrastructure/**", "com/sms/satp/websocket/**.class", "com/sms/satp/config/**.class", "com/sms/satp/controller/**")
    })
    dependsOn(tasks.test)
    reports {
        xml.required.set(false)
        csv.required.set(true)
    }


}



tasks.jacocoTestCoverageVerification {
    violationRules {
        rule {

//            excludes = listOf("**/entity/**.class","**/pojo/**.class","**/SatpApplication.class","**/response/Response.class","**/parser/common/**.class")
            limit {
                counter = "INSTRUCTION"
                value = "COVEREDRATIO"
                minimum = "0.6".toBigDecimal()
            }
        }

    }
}



tasks.test {
    finalizedBy(tasks.jacocoTestReport)
    useJUnitPlatform()
    testLogging {
        lifecycle {
            events = mutableSetOf(FAILED, PASSED, TestLogEvent.SKIPPED)
            exceptionFormat = FULL
            showExceptions = true
            showCauses = true
            showStackTraces = true
            showStandardStreams = true

        }
        info.events = lifecycle.events
        info.exceptionFormat = lifecycle.exceptionFormat
    }
    val failedTests = mutableListOf<TestDescriptor>()
    val skippedTests = mutableListOf<TestDescriptor>()
    addTestListener(object : TestListener {
        override fun beforeSuite(suite: TestDescriptor) {}
        override fun beforeTest(testDescriptor: TestDescriptor) {}
        override fun afterTest(testDescriptor: TestDescriptor, result: TestResult) {
            when (result.resultType) {
                TestResult.ResultType.FAILURE -> failedTests.add(testDescriptor)
                TestResult.ResultType.SKIPPED -> skippedTests.add(testDescriptor)
                else -> Unit
            }
        }

        override fun afterSuite(suite: TestDescriptor, result: TestResult) {
            if (suite.parent == null) { // root suite
                logger.lifecycle("----")
                logger.lifecycle("Test result: ${result.resultType}")
                logger.lifecycle(
                        "Test summary: ${result.testCount} tests, " +
                                "${result.successfulTestCount} succeeded, " +
                                "${result.failedTestCount} failed, " +
                                "${result.skippedTestCount} skipped")
                failedTests.takeIf { it.isNotEmpty() }?.prefixedSummary("\tFailed Tests")
                skippedTests.takeIf { it.isNotEmpty() }?.prefixedSummary("\tSkipped Tests:")
            }
        }

        private infix fun List<TestDescriptor>.prefixedSummary(subject: String) {
            logger.lifecycle(subject)
            forEach { test -> logger.lifecycle("\t\t${test.displayName()}") }
        }

        private fun TestDescriptor.displayName() = parent?.let { "${it.name} - $name" } ?: "$name"
    })
}

tasks.check {
    dependsOn(tasks.jacocoTestCoverageVerification)
}


tasks.withType<JavaCompile> {
    options.encoding = "UTF-8"

    options.compilerArgs.addAll(listOf("-Xlint:-unchecked", "-Xlint:none", "-nowarn", "-Xlint:-deprecation"))
    options.isWarnings = true
    options.isVerbose = true
    options.isDeprecation = false

}




